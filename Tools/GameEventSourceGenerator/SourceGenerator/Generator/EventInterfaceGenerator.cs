using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class EventInterfaceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // 可以在这里进行初始化  
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // 获取当前语法树  
        var syntaxTrees = context.Compilation.SyntaxTrees;

        var classNameList = new List<string>();

        foreach (var tree in syntaxTrees)
        {
            var root = tree.GetRoot();
            var eventInterfaces = root.DescendantNodes()
                .OfType<InterfaceDeclarationSyntax>()
                .Where(i => i.AttributeLists.Count > 0 &&
                            i.AttributeLists
                             .Any(a => a.Attributes
                             .Any(attr => attr.Name.ToString() == "EventInterface")));
            var existingUsings = root.DescendantNodes()
                .OfType<UsingDirectiveSyntax>()
                .Select(u => u.Name.ToString());


            foreach (var eventInterface in eventInterfaces)
            {
                var semanticModel = context.Compilation.GetSemanticModel(eventInterface.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(eventInterface)!;
                var namespaceName = symbol.ContainingNamespace.ToDisplayString();

                var eventInterfaceName = eventInterface.Identifier.ToString();

                var eventInterfaceFullName = eventInterface.SyntaxTree.GetRoot()
                .DescendantNodes()
                .OfType<NamespaceDeclarationSyntax>()
                .Select(ns => ns.Name.ToString())
                .Concat([eventInterfaceName])
                .Aggregate((a, b) => a + "." + b);

                // 生成实现类  
                var implementationClassCode = GenerateImplementationClass(existingUsings, namespaceName, eventInterfaceName, eventInterfaceFullName, eventInterface, context);
                context.AddSource($"{eventInterfaceName}_Gen.g.cs", implementationClassCode);

                classNameList.Add($"{eventInterfaceName}_Gen");
            }
        }

        string uniqueFileName = $"GameEventHelper.g.cs";
    }

    private string GenerateImplementationClass(IEnumerable<string> usings, string namespaceName, string eventInterfaceName, string eventInterfaceFullName, InterfaceDeclarationSyntax eventInterface, GeneratorExecutionContext context)
    {
        var semanticModel = context.Compilation.GetSemanticModel(eventInterface.SyntaxTree);
        var sb = new StringBuilder();

        sb.AppendLine($"//------------------------------------------------------------------------------");
        sb.AppendLine($"//	<auto-generated>");
        sb.AppendLine($"//		This code was generated by autoBindTool.");
        sb.AppendLine($"//		Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine($"//		the code is regenerated.");
        sb.AppendLine($"//	</auto-generated>");
        sb.AppendLine($"//------------------------------------------------------------------------------");
        sb.AppendLine();
        foreach (var item in usings)
        {
            sb.AppendLine($"using {item};");
        }
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine($"{{");
        sb.AppendLine($"    [EventGenClass]");
        sb.AppendLine($"    public partial class {eventInterfaceName}_Gen : {eventInterfaceFullName}");
        sb.AppendLine("    {");
        sb.AppendLine("        private EventDispatcher _dispatcher;");
        sb.AppendLine($"        private {eventInterfaceName}_Gen(EventDispatcher dispatcher)");
        sb.AppendLine("        {");
        sb.AppendLine("            _dispatcher = dispatcher;");
        sb.AppendLine("        }");

        foreach (var method in eventInterface.Members.OfType<MethodDeclarationSyntax>())
        {
            var methodName = method.Identifier.ToString();
            var parameters = GenerateParameters(method, semanticModel);

            sb.AppendLine($"        public static readonly int {methodName}ID = RuntimeId.ToRuntimeId($\"{{typeof({eventInterfaceFullName}).FullName}}.{{nameof({methodName})}} \");");
            sb.AppendLine($"        public void {methodName}({parameters})");
            sb.AppendLine("        {");
            if (method.ParameterList.Parameters.Count > 0)
            {
                var paramNames = string.Join(", ", method.ParameterList.Parameters.Select(p => p.Identifier.ToString()));
                sb.AppendLine($"            _dispatcher.Send({methodName}ID, {paramNames});");
            }
            else
            {
                sb.AppendLine($"            _dispatcher.Send({methodName}ID);");
            }
            sb.AppendLine("        }");
        }

        sb.AppendLine("        public static void RegWrapInterface(EventDispatcher dispatcher){");
        sb.AppendLine($"             GameEvent.EventMgr.RegWrapInterface(\"{eventInterfaceFullName}\", new {eventInterfaceName}_Gen(dispatcher));");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private string GenerateParameters(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        return string.Join(", ", method.ParameterList.Parameters.Select(p =>
        {
            var typeSymbol = semanticModel.GetTypeInfo(p.Type!).Type;
            return typeSymbol != null
                ? $"{typeSymbol.ToDisplayString()} {p.Identifier}"
                : $"{p.Type} {p.Identifier}";
        }));
    }
}